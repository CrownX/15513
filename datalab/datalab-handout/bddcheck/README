This directory contains code implementing a way to formally verify C
functions.  It contains the following files and subdirectories:

Subdirectories:
	cbit	Implements code to symbolically execute C 
		functions at a bit level.  See cbit/README for more information
	cudd-X.Y.Z
		Version X.Y.Z of the CUDD BDD package from the University
		of Colorado.

Files:
	check.pl:
		Checks correctness of function implementation.  Must be
		run from parent directory.  Specifically looks for function(s)
		in bits.c and it/their counterpart(s) in tests.c, extracts
		the code from the files, and runs it through cbit.  If it
		finds a discrepancy, it generates a C program to compile
		and test the counterexample.

		Can give it multiple function names on the command line
		
		Usage: bddcheck/check.pl fun1 fun2 ...

	checkprogs.pl, extractfun.pl:
		Helper code used by check.pl

	all-functions.txt:
		Contains information about the argument restrictions for
		the different datalab functions.


Installing CUDD:
        These instructions are valid as of CUDD 3.0.0
	> cd cudd-X.Y.Z
	> ./configure --prefix=$(pwd)/..
	> make
	> make install

The Makefile in bddcheck/ should be updated to compile everything
automatically now, even when checked out from Git.

The files checked into source control (such as ./configure) are pulled
directly from the CUDD tarfile. There should be no need to invoke the
autoconf tools (automake, autoreconf, etc.), since only the package
distributor needs to do this.

However, files like Makefile will be autogenerated by ./configure and
therefore should not be checked in.


INSTALLATION NOTE for CUDD:

If you retrieved the code via git, then the file dates will be
incorrect.  This can lead to problems with autoconfiguration, and
possibly cause the make command to fail.  The quick work around is to
execute the command:

   touch Makefile.am Makefile.in aclocal.m4

before executing the make command.
 ? -1 : 0;
}
long test_distinctNegation(long x) {
    return (long) (x != -x);
}
long test_getByte(long x, long n)
{
    unsigned char byte = 0;
    switch(n) {
    case 0:
      byte = x;
      break;
    case 1:
      byte = x >> 8;
      break;
    case 2:
      byte = x >> 16;
      break;
    case 3:
      byte = x >> 24;
      break;
    case 4:
      byte = x >> 32;
      break;
    case 5:
      byte = x >> 40;
      break;
    case 6:
      byte = x >> 48;
      break;
    case 7:
      byte = x >> 56;
      break;
    }
    return (long) (unsigned) byte;
}
long test_anyEvenBit(long x) {
  int i;
  for (i = 0; i < 64; i+=2)
      if (x & (1L<<i))
   return 1L;
  return 0L;
}
//3
long test_conditional(long x, long y, long z)
{
  return x?y:z;
}
long test_subtractionOK(long x, long y)
{
  __int128 ldiff = (__int128) x - y;
  return (long) (ldiff == (long) ldiff);
}
long test_isLessOrEqual(long x, long y)
{
    return (long) (x <= y);
}
long test_bitMask(long highbit, long lowbit)
{
  long result = 0L;
  int i;
  for (i = lowbit; i <= highbit; i++)
    result |= 1L << i;
  return result;
}
//4
long test_trueThreeFourths(long x)
{
  return (long) (((__int128) x * 3L)/4L);
}
long test_bitCount(long x) {
  long result = 0;
  long i;
  for (i = 0; i < 64; i++)
    result += (x >> i) & 0x1;
  return result;
}
//float
unsigned test_floatNegate(unsigned uf) {
    float f = u2f(uf);
    float nf = -f;
    if (isnan(f))
 return uf;
    else
 return f2u(nf);
}
int test_floatIsLess(unsigned uf, unsigned ug) {
    float f = u2f(uf);
    float g = u2f(ug);
    return f < g;
}
unsigned test_floatScale4(unsigned uf) {
  float f = u2f(uf);
  float tf = 4*f;
  if (isnan(f))
    return uf;
  else
    return f2u(tf);
}
